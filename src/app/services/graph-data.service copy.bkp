import { Injectable, inject } from '@angular/core';
import { forkJoin, map, Observable, of, catchError } from 'rxjs';
import { MetricsService } from './metrics.service';

export type NodeType = 'DIRECTORY' | 'FILE' | 'CLASS' | 'FUNCTION';

export interface GraphNode {
  id: string;
  label: string;
  type: NodeType;
  parentId?: string;
  children?: GraphNode[];
  loc?: number;
  x?: number;
  y?: number;
  depth?: number;
}

export interface GraphLink {
  source: string;
  target: string;
  value: number;
  type: 'DEPENDENCY' | 'COUPLING' | 'CALL';
  direction?: 'fan-in' | 'fan-out';
}

export interface HierarchicalData {
  nodes: GraphNode[];
  links: GraphLink[];
}

@Injectable({ providedIn: 'root' })
export class GraphDataService {
  private metrics = inject(MetricsService);

  loadHierarchy(repoId: string): Observable<HierarchicalData> {
    const req = (name: string) =>
      this.metrics.getMetric(repoId, name).pipe(catchError(() => of({ result: {} })));



    return forkJoin({
      files: req('files'),
      loc: this.metrics.getLocSloc(repoId).pipe(catchError(() => of({ byFile: {} }))),
      dependencies: this.metrics.getDependencies(repoId).pipe(catchError(() => of({ graph: {} }))),
      classes: req('classes-per-file'),
      classCoupling: req('class-coupling'),
      funcs: req('functions-per-file'),
      funcCoupling: req('function-coupling')
    }).pipe(
      map(data => this.buildGraph(data))
    );
  }

  private buildGraph(data: any): HierarchicalData {
    const nodesMap = new Map<string, GraphNode>();
    const links: GraphLink[] = [];

    // --- 1. DIRECTORIES & FILES ---
    let filePaths: string[] = [];
    if (Array.isArray(data.files)) filePaths = data.files;
    else if (Array.isArray(data.files?.result)) filePaths = data.files.result;
    else filePaths = Object.keys(data.dependencies?.graph || {});

    filePaths.forEach(path => {
      const parts = path.split('/');
      const fileName = parts.pop()!;

      let currentPath = '';
      let parentId: string | undefined = undefined;
      let depth = 0;

      // Create Directory Nodes
      parts.forEach(part => {
        const id = currentPath ? `${currentPath}/${part}` : part;

        if (!nodesMap.has(id)) {
          const dirNode: GraphNode = {
            id,
            label: part,
            type: 'DIRECTORY',
            parentId: parentId,
            children: [],
            depth: depth
          };
          nodesMap.set(id, dirNode);

          if (parentId) {
            const p = nodesMap.get(parentId)!;
            p.children = p.children || [];
            if (!p.children.find(c => c.id === id)) p.children.push(dirNode);
          }
        }

        currentPath = id;
        parentId = id;
        depth++;
      });
      console.log(`data: ${JSON.stringify(data)}`);
      // Create File Node
      const fileNode: GraphNode = {
        id: path,
        label: fileName,
        type: 'FILE',
        parentId: parentId,
        children: [],
        loc: data.loc?.byFile?.[path]?.loc || 10,
        depth: depth
      };
      nodesMap.set(path, fileNode);

      if (parentId) {
        const p = nodesMap.get(parentId)!;
        p.children = p.children || [];
        p.children.push(fileNode);
      }
    });

    // File Dependencies (Imports)
    const depGraph = data.dependencies?.graph || {};
    Object.entries(depGraph).forEach(([src, imports]: [string, any]) => {
      if (!nodesMap.has(src)) return;
      (imports as string[]).forEach(target => {
        if (nodesMap.has(target)) {
          links.push({ source: src, target: target, value: 1, type: 'DEPENDENCY' });
        }
      });
    });

    // --- 2. CLASSES ---
    const classesObj = data.classes?.result || {};
    Object.entries(classesObj).forEach(([file, clsMap]: [string, any]) => {
      if (!nodesMap.has(file)) return;
      const parent = nodesMap.get(file)!;

      Object.entries(clsMap).forEach(([className, details]: [string, any]) => {
        const id = `${file}::${className}`;
        const node: GraphNode = {
          id,
          label: className,
          type: 'CLASS',
          parentId: file,
          children: [],
          loc: 1,
          depth: (parent.depth || 0) + 1
        };
        nodesMap.set(id, node);
        parent.children?.push(node);

        // Create nodes for methods listed in classes-per-file
        const methods = details.methods || [];
        if (Array.isArray(methods)) {
          methods.forEach((methodName: string) => {
            const methodId = `${id}::${methodName}`;
            if (!nodesMap.has(methodId)) {
              const methodNode: GraphNode = {
                id: methodId,
                label: methodName,
                type: 'FUNCTION',
                parentId: id,
                loc: 1,
                depth: (node.depth || 0) + 1
              };
              nodesMap.set(methodId, methodNode);
              node.children?.push(methodNode);
            }
          });
        }
      });
    });

    // --- 3. FUNCTIONS (Standalone & Mapping) ---
    const funcsObj = data.funcs?.result || {};
    Object.entries(funcsObj).forEach(([file, funcMap]: [string, any]) => {
      if (!nodesMap.has(file)) return;
      const fileNode = nodesMap.get(file)!;

      Object.keys(funcMap).forEach(funcName => {
        // Check if function belongs to a class (by naming convention)
        const parentClass = fileNode.children?.find(c =>
          c.type === 'CLASS' && (funcName.startsWith(c.label + '.') || funcName.startsWith(c.label + '::'))
        );

        const id = `${file}::${funcName}`;
        if (nodesMap.has(id)) return;

        const label = funcName.split('.').pop() || funcName;
        const parentId = parentClass ? parentClass.id : file;
        const parentDepth = parentClass ? parentClass.depth : fileNode.depth;

        const node: GraphNode = {
          id,
          label,
          type: 'FUNCTION',
          parentId: parentId,
          loc: 1,
          depth: (parentDepth || 0) + 1
        };

        nodesMap.set(id, node);

        if (parentClass) {
          parentClass.children = parentClass.children || [];
          parentClass.children.push(node);
        } else {
          // FIX: Add standalone functions to file children
          fileNode.children = fileNode.children || [];
          fileNode.children.push(node);
        }
      });
    });

    // --- 4. CLASS COUPLING (Links) ---
    // Use class coupling data to find which classes in which files depend on other classes
    const clsCoupling = data.classCoupling?.result || {};
    const classToFileMap = new Map<string, string>(); // className -> file path

    // Build map of class name to file
    Object.entries(classesObj).forEach(([file, clsMap]: [string, any]) => {
      Object.keys(clsMap).forEach(className => {
        classToFileMap.set(className, file);
      });
    });

    // Aggregate coupling at CLASS level (not method level)
    const classCouplingLinks = new Map<string, number>(); // "class1Id->class2Id" -> count

    Object.entries(clsCoupling).forEach(([file, clsMap]: [string, any]) => {
      Object.entries(clsMap).forEach(([srcClassName, methods]: [string, any]) => {
        if (!Array.isArray(methods)) return;

        const srcClassId = `${file}::${srcClassName}`;
        if (!nodesMap.has(srcClassId)) return;

        // Aggregate all method fan-outs to class level
        methods.forEach((method: any) => {
          const fanOut = method['fan-out'] || {};
          Object.entries(fanOut).forEach(([targetClassName, targetMethods]: [string, any]) => {
            const targetClassFile = classToFileMap.get(targetClassName);
            if (!targetClassFile) return;

            const targetClassId = `${targetClassFile}::${targetClassName}`;
            if (!nodesMap.has(targetClassId)) return;

            // Aggregate count for this CLASS->CLASS pair
            if (srcClassId !== targetClassId) {
              const linkKey = `${srcClassId}->${targetClassId}`;
              const totalCount = Object.values(targetMethods as any).reduce((sum: number, val: any) =>
                sum + (typeof val === 'number' ? val : 0), 0
              );
              classCouplingLinks.set(linkKey, (classCouplingLinks.get(linkKey) || 0) + totalCount);
            }
          });
        });
      });
    });

    // Convert aggregated links to link array
    classCouplingLinks.forEach((count, linkKey) => {
      const [srcId, targetId] = linkKey.split('->');
      links.push({ source: srcId, target: targetId, value: count, type: 'COUPLING' });
    });

    // --- 5. FUNCTION COUPLING (Links) ---
    // Use function coupling data to identify function-to-function calls across files
    const fnCoupling = data.funcCoupling?.result || {};
    const functionToFileMap = new Map<string, string>(); // funcName -> file path

    // Build map of function name to file
    Object.entries(funcsObj).forEach(([file, funcMap]: [string, any]) => {
      Object.keys(funcMap).forEach(funcName => {
        // Store with full reference for lookup
        if (!functionToFileMap.has(funcName)) {
          functionToFileMap.set(funcName, file);
        }
      });
    });

    // Aggregate function calls at FUNCTION level
    const functionCallLinks = new Map<string, number>(); // "func1Id->func2Id" -> count

    Object.entries(fnCoupling).forEach(([srcFile, fnMap]: [string, any]) => {
      Object.entries(fnMap).forEach(([srcFuncName, details]: [string, any]) => {
        const srcFuncId = `${srcFile}::${srcFuncName}`;
        if (!nodesMap.has(srcFuncId)) return;

        const fanOut = details['fan-out'] || {};
        Object.entries(fanOut).forEach(([targetFuncName, count]: [string, any]) => {
          const targetFile = functionToFileMap.get(targetFuncName);
          if (!targetFile) return;

          const targetFuncId = `${targetFile}::${targetFuncName}`;
          if (!nodesMap.has(targetFuncId) || srcFuncId === targetFuncId) return;

          // Aggregate count
          const linkKey = `${srcFuncId}->${targetFuncId}`;
          functionCallLinks.set(linkKey, (functionCallLinks.get(linkKey) || 0) + Number(count));
        });
      });
    });

    // Convert aggregated links to link array
    functionCallLinks.forEach((count, linkKey) => {
      const [srcId, targetId] = linkKey.split('->');
      links.push({ source: srcId, target: targetId, value: count, type: 'CALL' });
    });

    return { nodes: Array.from(nodesMap.values()), links };
  }

  private findFunctionNode(map: Map<string, GraphNode>, file: string, funcName: string): GraphNode | undefined {
    // 1. Try exact ID match
    let id = `${file}::${funcName}`;
    if (map.has(id)) return map.get(id);

    // 2. Try finding it as a child of the file (standalone)
    const fileNode = map.get(file);
    if (fileNode && fileNode.children) {
      const child = fileNode.children.find(c => c.label === funcName && c.type === 'FUNCTION');
      if (child) return child;
    }

    // 3. Try finding it as a method of a class in the file
    // funcName might be "ClassName.methodName"
    for (const node of map.values()) {
      if (node.parentId === file || node.id.startsWith(file)) {
        if (node.label === funcName) return node;
        if (node.id.endsWith(`::${funcName}`)) return node;
      }
    }
    return undefined;
  }

  private findFunctionNodeGlobal(map: Map<string, GraphNode>, funcName: string): GraphNode | undefined {
    for (const node of map.values()) {
      if (node.type === 'FUNCTION') {
        // Exact label match
        if (node.label === funcName) return node;

        // ID suffix match (file::funcName)
        if (node.id.endsWith(`::${funcName}`)) return node;

        // Class.method match
        const parts = node.id.split('::');
        if (parts.length >= 3) {
          const method = parts.pop();
          const cls = parts.pop();
          if (`${cls}.${method}` === funcName) return node;
        }
      }
    }
    return undefined;
  }

  private findClassId(map: Map<string, GraphNode>, shortName: string): string | undefined {
    for (const node of map.values()) {
      if (node.type === 'CLASS' && node.label === shortName) return node.id;
    }
    return undefined;
  }
}